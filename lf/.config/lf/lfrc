# Basic Settings
set previewer ~/.config/lf/preview
set preview true
set hidden true
set drawbox true
set icons true
set ignorecase true
set shellopts '-eu'
set ifs "\n"
set scrolloff 10

### KEYBINDS ###
# Remove some defaults
map m
map o
map n
map "'"
map '"'
map d
map c
map e
map f

# File Operations
map DD delete
map dd trash-put
map md mkdir
map mf mkfile
map msc mkscript
map mss mkscript
map me make-executable
map re remove-executable
map ee $${EDITOR:-nvim} "$f"

# Basic Operations
map . set hidden!
map p paste
map mv cut-multi
map y copy
map <enter> open
map r rename
map H top
map L bottom
map R reload
map C clear
map U unselect

# Archive Mappings
map ex extract
map er archive

# Trash
map be trash-empty
map br trash-restore

# Jumping Around The Filesystem
map gh :cd ~
map gc :cd ~/.config
map gd :cd ~/Downloads
map gD :cd ~/Documents
map gv :cd ~/Videos
map gm :cd ~/Music
map gg :cd ~/Github
map gs :cd ~/Github/dotfiles-stow
map gC :cd ~/Github/Catalyst
map gw :cd ~/Pictures/Wallpapers
map gs :cd ~/Pictures/Screenshots
map gp :cd ~/Pictures
map gS :cd ~/Scripts
map gP :cd ~/Projects
map gf follow-link

# Fzf
map fj fzf_jump_dir
map fk fzf_jump_file

# Executing Scripts
map x $"$f"
map X !"$f"

# Wallpaper
map bg setbg

### CUSTOM COMMANDS ###
cmd open ${{
    mime="$(file --mime-type -Lb "$f")"
    ext="${f##*.}"

    case "$mime" in
        text/*|application/json|application/xml)
            ${EDITOR:-nvim} "$f"
            ;;
        image/*)
            command -v sxiv >/dev/null && sxiv "$f" ||
            command -v imv  >/dev/null && imv "$f"
            ;;
        video/*|audio/*)
            mpv "$f"
            ;;
        application/pdf)
            command -v zathura >/dev/null && zathura "$f" ||
            command -v pdftotext >/dev/null && pdftotext "$f" - | less
            ;;
        *)
            # Fallback on extension if MIME is unrecognized
            case "$ext" in
                txt|md|json|js|sh|py|cpp|c|java|html|css|lua|ts|rs|go|yml|yaml)
                    command -v bat >/dev/null && bat "$f" || ${EDITOR:-nvim} "$f"
                    ;;
                jpg|jpeg|png|gif|bmp|webp|svg)
                    command -v sxiv >/dev/null && sxiv "$f" ||
                    command -v imv  >/dev/null && imv "$f"
                    ;;
                mp4|mkv|webm|avi|mov)
                    mpv "$f"
                    ;;
                mp3|flac|wav|ogg)
                    mpv "$f"
                    ;;
                pdf)
                    command -v zathura >/dev/null && zathura "$f" ||
                    command -v pdftotext >/dev/null && pdftotext "$f" - | less
                    ;;
                toml)
                    ${EDITOR:-nvim} "$f"
                    ;;
                *)
                    xdg-open "$f" >/dev/null 2>&1
                    ;;
            esac
            ;;
    esac
}}

# File Creation Operations
cmd mkdir %{{
  printf " Directory Name: "
  read -r ans
  if [ -n "$ans" ]; then
    mkdir -p -- "$ans" && echo "Created: $ans" || echo "Failed to create directory."
    lf -remote 'send reload'
  else
    echo "No directory name entered."
  fi
}}

cmd mkfile ${{
  clear
  printf "File Name: "
  read -r ans
  if [ -n "$ans" ]; then
    : > "$ans"  # Touch file safely
    ${EDITOR:-nvim} "$ans"
    lf -remote 'send reload'
  else
    echo "No file name entered."
  fi
}}

cmd mkscript ${{
  clear
  mkscript && echo "Complex Script created."
  lf -remote 'send reload'
}}

cmd mkscr ${{
  clear
  mkscr && echo "Simple Script created."
  lf -remote 'send reload'
}}

# Filesystem Operations
cmd make-executable ${{
  if chmod a+x -- "$f"; then
    echo "Made executable: $f"
    lf -remote 'send reload'
  else
    echo "Failed to change permissions."
  fi
}}

cmd remove-executable ${{
  if chmod a-x -- "$f"; then
    echo "Removed executable permission: $f"
    lf -remote 'send reload'
  else
    echo "Failed to change permissions."
  fi
}}

# Trashing 
cmd trash-put %{{
  trash-put $fx
}}

cmd trash-empty ${{
    clear
    printf "Would you like to see what's inside the trash? [y/n]: "
    read -r ans
    case "${ans}" in
        y)
            clear
            echo -e "\033[1mContents of your trash:\033[0m"
            trash-list || echo "Failed to list trash."
            echo
            printf "Empty the trash now? [y/n]: "
            read -r confirm
            case "${confirm}" in
                y) trash-empty -f ;;
                n) echo "Trash not emptied." ;;
                *) echo "Invalid input. Expected 'y' or 'n'." ;;
            esac
            ;;
        n)
            trash-empty -f
            ;;
        *)
            echo "Invalid input. Expected 'y' or 'n'."
            ;;
    esac
}}

cmd trash-restore ${{
  clear
  trash-restore
}}

# Extract Archives
cmd extract %{{
  clear
  if [ -f "$f" ]; then
      case "$f" in
          *.tar.bz2) tar xjf "$f"    ;;
          *.tar.gz)  tar xzf "$f"    ;;
          *.bz2)     bunzip2 "$f"    ;;
          *.rar)     unrar x "$f"    ;;
          *.gz)      gunzip "$f"     ;;
          *.tar)     tar xf "$f"     ;;
          *.tbz2)    tar xjf "$f"    ;;
          *.tgz)     tar xzf "$f"    ;;
          *.zip)     unzip "$f"      ;;
          *.Z)       uncompress "$f" ;;
          *.7z)      7z x "$f"       ;;
          *.deb)     ar x "$f"       ;;
          *.tar.xz)  tar xf "$f"     ;;
          *.tar.zst) unzstd "$f"     ;;
          *)         echo " '$f' cannot be extracted via extract" ;;
      esac
  else
      echo " '$f' is not a valid file"
  fi
}}

# Compressing Current Selected File 
cmd archive %{{
  clear
  printf " Archive name (with .tar.gz, .zip, or .rar): "
  read -r archive_name

  if [ -z "$archive_name" ]; then
    echo " No archive name provided."
    exit 1
  fi

  if [ -e "$archive_name" ]; then
    echo " Error: Archive '$archive_name' already exists."
    exit 1
  fi

  case "$archive_name" in
    *.tar.gz)
      tar -czf "$archive_name" $fs ;;
    *.zip)
      zip -r "$archive_name" $fs ;;
    *.rar)
      if command -v rar > /dev/null; then
        rar a "$archive_name" $fs
      else
        echo " Error: 'rar' is not installed."
        exit 1
      fi ;;
    *)
      echo " Unsupported format: use .tar.gz, .zip, or .rar"
      exit 1 ;;
  esac

  if [ $? -eq 0 ]; then
    echo " Success: Created $archive_name"
    lf -remote 'send reload'
  else
    echo " Failed to create archive."
  fi
}}

# Fzf Jump
cmd fzf_jump_dir ${{
    # Find directories up to 3 levels deep (excluding .)
    res="$(find . -mindepth 1 -maxdepth 3 -type d 2>/dev/null | fzf \
        --reverse \
        --header='Jump to directory' \
        --preview 'ls -1 --color=always {}' \
        --preview-window=down:10:wrap)"

    # If selected, send 'cd' command to lf
    if [ -n "$res" ]; then
        lf -remote "send $id cd \"$res\""
    fi
}}

cmd fzf_jump_file ${{
    # Find directories up to 3 levels deep (excluding .)
    res="$(find . -mindepth 1 -maxdepth 3 -type f 2>/dev/null | fzf \
        --reverse \
        --header='Jump to directory' \
        --preview 'ls -1 --color=always {}' \
        --preview-window=down:10:wrap)"

    # If selected, send 'cd' command to lf
    if [ -n "$res" ]; then
      ${EDITOR:-nvim} "$res"
    fi
}}

cmd follow-link ${{
    if [ ! -L "$f" ]; then
        echo "Not a symlink: $f"
        exit 1
    fi

    target="$(readlink -f "$f")"

    if [ -d "$target" ]; then
        # Target is a directory, cd into it
        lf -remote "send $id cd \"$target\""
    elif [ -f "$target" ]; then
        # Target is a file, cd into its parent directory
        parent_dir=$(dirname "$target")
        if [ -d "$parent_dir" ]; then
            lf -remote "send $id cd \"$parent_dir\""
            ${EDITOR:-nvim} "$target"
        else
            echo "Parent directory does not exist: $parent_dir"
        fi
    else
        echo "Target is neither file nor directory: $target"
    fi
}}

cmd cut-multi %{{
  printf " Move to directory: "
  read -r dest

  if [ -z "$dest" ] || [ ! -d "$dest" ]; then
    echo " Invalid destination: $dest defaulting to ./"
    dest="."
  fi

  for file in $fs; do
    mv -- "$file" "$dest/" || echo " Failed to move: $file"
  done

  lf -remote 'send reload'
}}

# Wallpaper
cmd setbg ${{
  tmp_wall="$HOME/.config/wall.png"

  if cp -- "$f" "$tmp_wall"; then
    xwallpaper --stretch "$tmp_wall"
    rm -f -- "$tmp_wall"
    lf -remote 'send reload'
  else
    echo " Failed to copy wallpaper."
  fi
}}
